---
layout: post
title:  "Tomcat源码分析心得"
categories: tomcat
tags:  java tomcat  
author: malefooo
---

* content
{:toc}


## 前言

突然就想tomcat是什么，他有什么用，然后就开始了源码阅读之路，本人是个刚转行1年多的小菜鸟。
基础也很不扎实，在看源码很多不懂就去查，一下子就理解了当时不太理解的一些定义，也就顺便写了下来。
真的很菜，逻辑也不清楚，希望大家看了能有帮助，有错误的地方多多包涵，告诉我我就去改正。

这就开始Tomcat的学习之路吧！
<!-- more -->

##  第一次撸码

打开整个项目，搜索了一下lifecycle（生命周：接口），就从这个类开始看了
查看了一下其实现类

![](http://i1.bvimg.com/679735/40a24299f02549d7.png)

![](http://i1.bvimg.com/679735/0bc3c52aa9e267f8.png)

![](http://i1.bvimg.com/679735/4f78396b3da01c33.png)

![](http://i1.bvimg.com/679735/05cfe15459ffe051.png)

这些关键的组件都继承来lifecycle这个接口，方便管理呀，关了就一起关，
启动初始化时也一起启动，具体实现我要慢慢研究一下，毕竟是一个很成熟的大项目，要细细研究一下。


放一张lifecycle的启动流程图（是在源代码中的哦）

![](http://i1.bvimg.com/679735/e3a87b2fbdf5fd86.png)

整个过程是非常清晰的，每个过程细化到启动前，启动中，启动后，等等。。

![](http://i1.bvimg.com/679735/3edba3135bc7933e.png)

```js

Server：服务器的意思，代表整个tomcat服务器，一个tomcat只有一个Server；
Service：Server中的一个逻辑功能层， 一个Server可以包含多个Service；
Connector：称作连接器，是Service的核心组件之一，一个Service可以有多个Connector，主要是连接客户端请求；
Container：Service的另一个核心组件，按照层级有Engine，Host，Context，Wrapper四种，一个Service只有一个Engine，其主要作用是执行业务逻辑；
Jasper：JSP引擎；
Session：会话管理；

```

看完了lifecycle，里边的方法和变量，定义了一些状态，我从这个类开始读，是因为我觉得所有的组件都含有这个接口的规范，好了，接下来看看server


interface server extends lifecycle
继承了lifecycle这个接口
其实现类就一个：standardServer

有一个疑问：有一个类叫做全局命名源：NamingResourcesImpl，我没理解用到这个有什么用，不过后面再补上把，先把大体框架弄懂
lifecycle<---server<---standardServer
继承关系：lifecycle<----lifecycleBase<----lifeMBeanBase<----StandardServer

```js

在看源码时，有很多的抽象类，我就在想，抽象类有什么用，只要接口不就行了么？而且抽象类不能被创建，这在面试中我还被问到一个问题：怎么样去阻止一个类不被创建，那就是抽象类啊，我竟然傻乎乎的没回答出来，可想而知我的基础时多么的糟糕，这么糟糕的基础就是因为我只会写代码，并不理解我所写代码语言的思想；有点跑题哈

接口：定义的是事物的属性和行为，主要是定义属性！！

抽象类：继承接口，然后实现接口中的方法，强迫子类必须重写，抽象类中更多是行为的实现。例如一个物种叫做LGDOG，他既是人又是狗，他不用狗的行为，却有狗的属性，同时他具有完整人类的行为，这时候他可以继承人类的抽象类和实现狗的接口，他不必实现狗的行为，但是他有狗的属性哦，但是如果他只实现狗的接口，这时候他就必须要强制实现狗的行为。

如果你想让其有一种抽象的行为又有另一种抽象的属性，就可以继承需要行为抽象的抽象类然后在继承需要属性的抽象接口。
当你实现了两个接口，两个接口中共有一个eat方法，参数也一样，这时候怎么判断是哪种抽象的吃呢？
没法判断，因为你是说名他们都要吃，并未实现这些方法是要怎么吃和吃什么，反正就知道是吃。要知道怎么吃，就只能靠各自的抽象类来重新说明，但是如果你想让LGDOG一会是人的吃法，一会又是狗的吃法，那这个是个特别的种类，需要重新把他定义为一种新的抽象，同时实现这两种实现，他有自己的抽象类来实现他自己的吃法，既不是人吃也不是狗吃，事LGDOG吃。
还是LGDOG把，他继承了人的行为含有狗的属性，这时候重新新建一个LGDOG，他的属性是父类的，但是行为是指向自己的。
从接口到抽象类在到一个普通类，所有的方法都是又来源可追的，每一个子类都有自己独特的个性同时也可溯源，找到最根本的方法。

```

继续看源码

![](http://i1.bvimg.com/679735/6db0aff899c15ecc.png)

这时候再来看继承关系图，就很好理解了。
StandardServer他的行为由LifecycleMBeanBase来实现。

server是最外层，所以他自己要先初始化

![](http://i1.bvimg.com/679735/abf5d8def73c2f2b.png)

这是个内部初始化方法，这里他初始化自己
当初始化顺利进行到最后就开始初始化内部的service方法

![](http://i1.bvimg.com/679735/10b708b5e0704a13.png)

service有很多个，所以要循环初始化
整个初始化我也看不是很懂，就知道他调用父类初始化，然后自己初始化，新建一个MBeanFactory工厂，里边有一个server容器，来装载这个新建的容器集此刻的Server，然后再把这个server注册到一个（我也不知道是啥的）地方。。。。
在看到catalina时，不知道是个啥玩意，这个Catalina在哪里出现呢？

![](http://i1.bvimg.com/679735/78ee6c1482c0e868.png)


对，就在初始化service上面，先要进行判断catalina是否为空，catalina这个类调用standardServer中的setcatalina这个方法，这个类没有任何继承
我不知道是啥，然后百度了一下，又是一片新天地

![](http://i1.bvimg.com/679735/64d20167e3865ad9.png)

就是apache的servlet容器的名字，tomcat所做的只是把这个servlet容器进行加载，装配和调用！
就好比在使用liat一样底层封装的时数组，我们使用tomcat，底层封装的就是Catalina！！！
tomcat和apache是什么关系！就好比卡车和卡车上的桶的关系！

## 第二次撸码
昨天第一天开始看代码，看的晕晕乎乎的，然后第二天开始整理了一下思路，其中中间看了两个视频，我觉得还不错，在底部我放出连接
第一次撸完之后休息了一天，这一天就去找视频看了，因为有点混乱，找不到一个头

开始撸码！

那么server时怎么开始加载的呢？
首先，找到启动类

![](http://i1.bvimg.com/679735/3fd34412cf4f39f1.png)

这个包下的Bootstrap
我们找到main函数

![](http://i1.bvimg.com/679735/c9833086bafabf99.png)

这里开始初始化

![](http://i1.bvimg.com/679735/9e3c78b8abb0ec42.png)

再初始化里边，初始化一个类加载器
再在里边通过反射来新建一个catalina类
然后启动了catalina里边的有一个setParentClassLoader方法，这个方法竟然比初始化和start都优先，他里边是什么呢？我们去看一看吧

![](http://i1.bvimg.com/679735/9e3c78b8abb0ec42.png)

这个方法就是把Bootstrap里边新建的类加载器传给了catalina。。。用得着这么节省么，再catalina里边在新建一个也行呀，这样是不是省的在去创建了呢？节省内存？我也不知道，还需要再去好好深究一下，如果有人懂的话可以教教我，一起学习。
好了，回到bootstrap类里边，回到main方法，此时初始化结束，到了接下来一步，判断当前的状态

![](http://i1.bvimg.com/679735/5b63c7210f0c1971.png)

这里判断的是main函数传进来的参数个数，在这里我们看到，他处理五个参数
“startd”，“stopd”，“stop”，“start”，“configtest”
在捕获是1和2时，将数组中这个参数编程不带d的
startd和start的区别时多了一个load，让我们看看这个load里边有啥，这里边有个数组，数组在这里传来传去，我判定这个数组参数应该就只会穿一个参数进去，要不load不能实现里边的方法

![](http://i1.bvimg.com/679735/0cdda058e2b7447d.png)

load的代码
最后又进到了catalina里边的load，里边的load就是创建并执行了一个Diagester，这个类是啥，我又不知道了，有机会去细究
大致意思就是重新配置了一下配置文件，并加载，如果失败就抛出异常，一个是catalina配置失败，另一个是catalina权限不足

```js
在这里我又要说一下catalina，希望大家没忘记这个类是什么？我们现在在看什么？因为整个启动过程很庞大，这里才说的是刚开始，我们现在在启动catalina，经由bootstrap来启动，启动这个水桶！要不水（servlet）怎么进得来，没有水我们怎么和客户端交互，客户端的请求我们怎么处理。
```

回到刚刚的main方法对command判断的之中去。
然后stop和stopd的区别就是，stopd还要关闭一个Diagester，二stop不需要关闭这个。
然后终于到启动了！
我们这个catalina！这个关键的servlet容器就要开始了！就要干活了！有点小激动啊。。。

![](http://i1.bvimg.com/679735/804c9334f51a472c.png)

关键就是标红的那里，getServer().start()
让catalina里边的服务起来，这个server哪来的，是由接口server的实现类来实现啊！你忘了server的实现类是哪个？不慌！我来放图

![](http://i1.bvimg.com/679735/6db0aff899c15ecc.png)

调用了这个start，我就去standardServer里边找，没找到start啊！这时候我就想到了，动态调用！

```js
有一句话是：动态绑定。
```

standardServer，LifecycleMBeanBase和LifecycleBase都是lifecycle的实现类呀（start是在lifecycle里边定义的方法）
然后我找了这三个，只有lifecycBase里边又start方法啊，看到这里，原来很多不懂得开始茅塞顿开，真的原来不在意的细节再这些大项目中一一体现出来。
废话少说，上图！

![](http://i1.bvimg.com/679735/30df5ab7d2bcf726.png)


## 第三次撸码

接着上次：
首先进行判断此时的状态，如果是启动前，启动中和已启动，就会进到if中
如果新建的，就进入init()中
如果失败的，就stop()
如果是非初始化结束或者是已停止的这两种状态，启动一个invalidTransition(Lifecycle.BEFORE_START_EVENT);（转换无效的方法，抛出一个异常）

此时开始设置一个内部状态，感觉这个start，是对生命周的一个状态的校准和设定
进去startInternal()看看

![](http://i1.bvimg.com/679735/4417aeca2885f723.png)

这是一个抽象类，当然大家就知道了，他的子类来实现这个方法。哪个子类呢？StandardServer啦
可能会问，其他子类不会继承么，好，那我们看看他的子类有哪些

![](http://i1.bvimg.com/679735/3513b5cbffc9af04.png)

这些子类中，就都是设置一个生命周期的状态，设置为starting
只有再StandardServer中有关于业务往下进行的逻辑
让我们回到StandardServer中

![](http://i1.bvimg.com/679735/3e7c4bb03e4fac49.png)

有一个service[i].start()
这就是服务启动的阶段了！，让我们进去看看，
这里边是一个数组，是父类Service的驻足类型，我们去看看他

![](http://i1.bvimg.com/679735/37d4e96e2af4f140.png)

同样继承了生命周期，Service的标准实现类

![](http://i1.bvimg.com/679735/e7ae9a8f7f91ded7.png)

我又找不到了。。。。
这个标准实现类中没有start这个方法。。。
怕什么，看看继承图，子类找不到，找他爹吧

![](http://i1.bvimg.com/679735/9ea835d201edd4a7.png)

由上图可知，他的父类是LifecycleMBeanBase
我们去看看这个类，这个类里边也没有，又继续回到lifecycBase里边了

这个运行才可之指向谁。。。
现在是真的确实理解到了，之前的catalina有一个getServer.start()哪个是指向server的，而这个service[].start()是指向Service的。
再lifecycleBase中的startInternal()调用，就到了StandardService中的startInternal()
我觉得我需要画一张图

![](http://i1.bvimg.com/679735/b71475e2ae1a4fc1.png)


看到这张图，清晰了很多呀，毕竟只靠文字和代码图片，在我这个菜鸟的闹钟就是一团浆糊
这是一个启动的大致流程，细节我就没有画
现在刚好看到service，后面会把整个启动流程补齐的


## 第四次撸码
昨天降温，脆弱的我直接感冒了，今天有所好转开始刷码更新

好了，说到StandardService

![](http://i1.bvimg.com/679735/47dd95065b7bbdb2.png)

在这个内部初始化的方法中，记住，这个方法是来自LifecycleBase的继承自Lifecycle

有一个engine.start() 和 conector.start() 一个是连接器 另一个是引擎，engine是什么呢？

![](http://i1.bvimg.com/679735/d2a025b593da6992.jpg)

这张图更为精准，engine和connector是平级的，我们先看engine吧

![](http://i1.bvimg.com/679735/17ff3543b7f3591d.png)

这个Engine继承了Container，那这个又是什么呢？

```js

public interface Container extends Lifecycle 

```

一样继承了Lifecycle

我们来看看官方给的说明

```js

/**
* A <b>Container</b> is an object that can execute requests received from
* a client, and return responses based on those requests. A Container may
* optionally support a pipeline of Valves that process the request in an
* order configured at runtime, by implementing the <b>Pipeline</b> interface
* as well.
* <p>
* Containers will exist at several conceptual levels within Catalina. The
* following examples represent common cases:
* <ul>
* <li><b>Engine</b> - Representation of the entire Catalina servlet engine,
* most likely containing one or more subcontainers that are either Host
* or Context implementations, or other custom groups.
* <li><b>Host</b> - Representation of a virtual host containing a number
* of Contexts.
* <li><b>Context</b> - Representation of a single ServletContext, which will
* typically contain one or more Wrappers for the supported servlets.
* <li><b>Wrapper</b> - Representation of an individual servlet definition
* (which may support multiple servlet instances if the servlet itself
* implements SingleThreadModel).
* </ul>
* A given deployment of Catalina need not include Containers at all of the
* levels described above. For example, an administration application
* embedded within a network device (such as a router) might only contain
* a single Context and a few Wrappers, or even a single Wrapper if the
* application is relatively small. Therefore, Container implementations
* need to be designed so that they will operate correctly in the absence
* of parent Containers in a given deployment.
* <p>
* A Container may also be associated with a number of support components
* that provide functionality which might be shared (by attaching it to a
* parent Container) or individually customized. The following support
* components are currently recognized:
* <ul>
* <li><b>Loader</b> - Class loader to use for integrating new Java classes
* for this Container into the JVM in which Catalina is running.
* <li><b>Logger</b> - Implementation of the <code>log()</code> method
* signatures of the <code>ServletContext</code> interface.
* <li><b>Manager</b> - Manager for the pool of Sessions associated with
* this Container.
* <li><b>Realm</b> - Read-only interface to a security domain, for
* authenticating user identities and their corresponding roles.
* <li><b>Resources</b> - JNDI directory context enabling access to static
* resources, enabling custom linkages to existing server components when
* Catalina is embedded in a larger server.
* </ul>
*
* @author Craig R. McClanahan
* @author Remy Maucherat
*/

翻译
/ ** 
* <b>容器</ b>是一个对象，可以执行从客户端收到的请求，并根据这些请求返回响应。 Container可以
*可选地支持Valves管道，它通过实现<b> Pipeline </ b>接口
*以运行时配置的*顺序处理请求。 
* <p> 
*容器将存在于Catalina内的几个概念层面。以下示例表示常见情况：
* <ul> 
* <li> <b>Engine</ b>  - 整个Catalina servlet引擎的表示，
*最有可能包含一个或多个Host 
*或Context实现的子容器，或其他自定义组。 
* <li> <b>Host</ b>  - 包含多个
*上下文的虚拟主机的表示。 
* <li> <b>Context</ b>  - 表示单个ServletContext，它通常包含一个或多个支持的servlet的Wrappers。 
* <li> <b> Wrapper </ b>  - 表示单个servlet定义
*（如果servlet本身*实现SingleThreadModel，则可以支持多个servlet实例）。 
* </ ul> 
* Catalina的给定部署不需要包含上述所有*级别的容器。例如，嵌入在网络设备（例如路由器）中的管理应用程序
*可能只包含*单个Context和一些Wrappers，如果*应用程序相对较小，甚至可能包含单个Wrapper。因此，需要设计Container实现
*，以便它们在给定部署中不存在父容器时正常运行。 
* <p> 
*容器还可以与许多支持组件
*相关联，这些组件提供可以共享的功能（通过将其附加到
*父容器）或单独定制。目前可识别以下支持
*组件：
* <ul> 
* <li> <b> Loader </ b>  - 用于将此Container的新Java类
*集成到运行Catalina的JVM中的类加载器。 
* <li> <b> Logger </ b>  - 实现<code> log（）</ code>方法
* <code> ServletContext </ code>接口的签名。 
*<li> <b>Manager</ b>  - 与*此容器相关联的会话池的经理。 
* <li> <b>Realm</ b>  - 安全域的只读接口，用于
*验证用户身份及其相应角色。 
* <li> <b>Resources</ b>  - 允许访问静态
*资源的JNDI目录上下文，当
* Catalina嵌入在更大的服务器中时，启用与现有服务器组件的自定义链接。 
* </ ul> 
*
* @author Craig R. McClanahan 
* @author Remy Maucherat 
* /

```

Container包含Engine------Engine包含Host------Host包含Context------Context包含Wrapper

来看看Container的标准实现类ContainerBase

![](http://i1.bvimg.com/679735/5ee819e0082a74a8.png)

![](http://i1.bvimg.com/679735/92d65402dc2b6019.png)

实现类有以下这几个，这几个都是容器，Container是他们的抽象

然后刚刚的Engine的start肯定是在ContainerBase里边的startInternal

![](http://i1.bvimg.com/679735/73dbd8e78859d29a.png)

这有一个children的数组，我们去看看怎么实现这个方法的

![](http://i1.bvimg.com/679735/b05f6da1fe51eff9.png)

有一个这个接口定义的方法，添加子类，一层一层的添加

```js

results.add(startStopExecutor.submit(new StartChild(children[i])));

```

这句代码对于本鸟来说有点陌生，就点进去看看，先从StartChild看起

![](http://i1.bvimg.com/679735/ca99730f4b08f69e.png)

一个继承了Callable接口的方法，看来是要在线程中执行，并且有返回值的，但是这里返回null了。
关键是一个child.start()
然我们看看Container的第一个容器的继承结构

![](http://i1.bvimg.com/679735/53f991a7cb22b4c4.png)

哦吼，有start就去找startInternal就ok

![](http://i1.bvimg.com/679735/ce0a9a1723c90e72.png)


调用父类的startInternal，这就成为一个循环了
这时候需要一波思维导图来理清一下思路


![](http://i1.bvimg.com/679735/fc173399dcfa61fb.png)

差不多就是这样，把一个个容器全部启动起来

在启动子容器时是新开一个线程

```js

startStopExecutor.submit()

```

我对这个不清楚，就去百度了一下


```js

在Java5以后，通过Executor来启动线程比用Thread的start()更好。在新特征中，可以很容易控制线程的启动、执行和关闭过程，还可以很容易使用线程池的特性。

```

这就是为什么用这个的原因

好了，看完container的启动流程，接下来我们看connector的启动流程

回到StandardService的startInternal方法中

![](http://i1.bvimg.com/679735/47dd95065b7bbdb2.png)

我们先来看看Connector的继承图

![](http://i1.bvimg.com/679735/4177d3960b632d1b.png)

这一套继承关系我们已经很熟悉了，直接去找startInternal()

![](http://i1.bvimg.com/679735/6f5ab15fec6762c5.png)

在图中，关键的就是这个协议处理器，我们进去看看

![](http://i1.bvimg.com/679735/444a9bfdcb436f04.png)

这是ProtocolHandler接口定义的方法，里边有一个适配器Adapter，这个一会我们再看，
看一下协议处理器的实现类

![](http://i1.bvimg.com/679735/d600ae6ccc38ad85.png)

有这些处理协议

![](http://i1.bvimg.com/679735/447a442db0e8001d.png)

start的方法，启动一个端点，然后在延时启动一个异步方法

我们先看看端点的启动


进入到一个startInternal()的方法中，这个方法是抽象方法

![](http://i1.bvimg.com/679735/3e8b747d72f953ec.png)


要由子类来实现，然后我打开看了一下实现类

![](http://i1.bvimg.com/679735/5445a6f5acf6a742.png)

这要动态绑定哪个啊。。。。。。

又去百度爸爸那里查一查吧，看看有没有什么收获
果然，看到一篇博客，有这么一句话

```js

在Http11NioProtocol的构造函数中指定的是使用NioEndpoint实例，因此这里通过分析AbstractEndpoint的子类NioEndpoint来做进一步的了解。
这里主要关注bind和startInternal两个函数

```

原来使用哪个endpoint是由protocol来决定的。。
那我们转头回去看startAsyncTimeout这个方法

![](http://i1.bvimg.com/679735/57553f865cc65710.png)


这个方法，根据这个set中的处理器来动态绑定哪个子类，那我们看看，在哪里往这个set中添加了Processor
找到了，在内部类ConnectorHandler中

![](http://i1.bvimg.com/679735/98416ecf525533c7.png)

这个内部类很有意思了

```js

protected static class ConnectionHandler<S> implements AbstractEndpoint.Handler<S>

```

实现了这个接口，我们进去看看

![](http://i1.bvimg.com/679735/8cea19bd74cb9043.png)

这个接口是一个抽象类里边的静态接口。。。
我又要去百度一下了，这样写有什么用，似乎没找到，那就自己研究研究吧

```js

* @param <S> The type used by the socket wrapper associated with this endpoint.
* May be the same as U.
* @param <U> The type of the underlying socket used by this endpoint. May be
* the same as S.

翻译
* @param <S>与此端点关联的套接字包装器使用的类型。 
*可能与U相同。
* @param <U>此端点使用的底层套接字的类型。可能
*与S相同

```

传进来两个泛型，都是套接字类型，这时候设计模式可能就能榜上我的忙了，这种编码风格，我看的云里雾里
看到了一篇博客是这么说的

```js

Tomcat中的Connector将具体的协议处理托管给了不同的ProtocolHandler实现类.这些实现类都内置这一个很重要的对象,AbstractEndpoint这是一个抽象类,不同的协议需要提供不同的Endpoint.
这个类的作用就是提供底层的网络I/O的处理.不同的ProtocolHandler所内置的Endpoint是不同的.但是AbstractEndpoint为这些类抽象出了一个具体的实现框架.首先了解下AbstractEndpoint的一系列内部类(接口).Acceptor是其中职能最重要的,它是一个抽象类（我看了一下是普通类，可能是作者写错了？）,
拓展了Runable接口.从名字中可以很容易知道它的作用就是用来接收底层的Socket连接.而具体的实现就需要到具体的协议中去探究.比较重要的内部接口是Handler.它的作用是定义连接的处理.也就是后面被实现成各个版本是ConnectionHandler.

```

![](http://i1.bvimg.com/679735/9821c3aef57a572f.png)

找到一篇是13年的，里边说的类都和现在的不一样了，那就自己来看看吧
看了好一会，我决定还是先看看书了，用两天把《深入剖析Tomcat》看完先吧，我的水平，看到connector这一块根本毫无进展就是浪费时间，过后再更了

## 资源/资料

endpoint：https://blog.csdn.net/LWJdear/article/details/77893057

AbstractEndpoint：https://blog.csdn.net/iteye_14395/article/details/82541097

ExecutorService：https://blog.csdn.net/qq_17058993/article/details/80235919

动态绑定：https://www.cnblogs.com/xdp-gacl/p/3644035.html

手写tomcat视频：https://study.163.com/course/courseLearn.htm?courseId=1209045863&from=study#/learn/live?lessonId=1278567398&courseId=1209045863

tomcat原理分析视频：https://study.163.com/course/introduction/1006122005.htm

《深入剖析Tomcat》百度云：https://pan.baidu.com/s/1XgSDR56zwGD5850MIy0HCA 提取码：snog


